{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst events_1 = require(\"events\");\nconst is_1 = require(\"@sindresorhus/is\");\nconst PCancelable = require(\"p-cancelable\");\nconst types_1 = require(\"./types\");\nconst parse_body_1 = require(\"./parse-body\");\nconst core_1 = require(\"../core\");\nconst proxy_events_1 = require(\"../core/utils/proxy-events\");\nconst get_buffer_1 = require(\"../core/utils/get-buffer\");\nconst is_response_ok_1 = require(\"../core/utils/is-response-ok\");\nconst proxiedRequestEvents = ['request', 'response', 'redirect', 'uploadProgress', 'downloadProgress'];\nfunction asPromise(normalizedOptions) {\n  let globalRequest;\n  let globalResponse;\n  const emitter = new events_1.EventEmitter();\n  const promise = new PCancelable((resolve, reject, onCancel) => {\n    const makeRequest = retryCount => {\n      const request = new core_1.default(undefined, normalizedOptions);\n      request.retryCount = retryCount;\n      request._noPipe = true;\n      onCancel(() => request.destroy());\n      onCancel.shouldReject = false;\n      onCancel(() => reject(new types_1.CancelError(request)));\n      globalRequest = request;\n      request.once('response', async response => {\n        var _a;\n        response.retryCount = retryCount;\n        if (response.request.aborted) {\n          // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error\n          return;\n        }\n        // Download body\n        let rawBody;\n        try {\n          rawBody = await get_buffer_1.default(request);\n          response.rawBody = rawBody;\n        } catch (_b) {\n          // The same error is caught below.\n          // See request.once('error')\n          return;\n        }\n        if (request._isAboutToError) {\n          return;\n        }\n        // Parse body\n        const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();\n        const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);\n        const {\n          options\n        } = request;\n        if (isCompressed && !options.decompress) {\n          response.body = rawBody;\n        } else {\n          try {\n            response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);\n          } catch (error) {\n            // Fallback to `utf8`\n            response.body = rawBody.toString();\n            if (is_response_ok_1.isResponseOk(response)) {\n              request._beforeError(error);\n              return;\n            }\n          }\n        }\n        try {\n          for (const [index, hook] of options.hooks.afterResponse.entries()) {\n            // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n            // eslint-disable-next-line no-await-in-loop\n            response = await hook(response, async updatedOptions => {\n              const typedOptions = core_1.default.normalizeArguments(undefined, {\n                ...updatedOptions,\n                retry: {\n                  calculateDelay: () => 0\n                },\n                throwHttpErrors: false,\n                resolveBodyOnly: false\n              }, options);\n              // Remove any further hooks for that request, because we'll call them anyway.\n              // The loop continues. We don't want duplicates (asPromise recursion).\n              typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);\n              for (const hook of typedOptions.hooks.beforeRetry) {\n                // eslint-disable-next-line no-await-in-loop\n                await hook(typedOptions);\n              }\n              const promise = asPromise(typedOptions);\n              onCancel(() => {\n                promise.catch(() => {});\n                promise.cancel();\n              });\n              return promise;\n            });\n          }\n        } catch (error) {\n          request._beforeError(new types_1.RequestError(error.message, error, request));\n          return;\n        }\n        globalResponse = response;\n        if (!is_response_ok_1.isResponseOk(response)) {\n          request._beforeError(new types_1.HTTPError(response));\n          return;\n        }\n        request.destroy();\n        resolve(request.options.resolveBodyOnly ? response.body : response);\n      });\n      const onError = error => {\n        if (promise.isCanceled) {\n          return;\n        }\n        const {\n          options\n        } = request;\n        if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {\n          const {\n            response\n          } = error;\n          resolve(request.options.resolveBodyOnly ? response.body : response);\n          return;\n        }\n        reject(error);\n      };\n      request.once('error', onError);\n      const previousBody = request.options.body;\n      request.once('retry', (newRetryCount, error) => {\n        var _a, _b;\n        if (previousBody === ((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body) && is_1.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {\n          onError(error);\n          return;\n        }\n        makeRequest(newRetryCount);\n      });\n      proxy_events_1.default(request, emitter, proxiedRequestEvents);\n    };\n    makeRequest(0);\n  });\n  promise.on = (event, fn) => {\n    emitter.on(event, fn);\n    return promise;\n  };\n  const shortcut = responseType => {\n    const newPromise = (async () => {\n      // Wait until downloading has ended\n      await promise;\n      const {\n        options\n      } = globalResponse.request;\n      return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);\n    })();\n    Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n    return newPromise;\n  };\n  promise.json = () => {\n    const {\n      headers\n    } = globalRequest.options;\n    if (!globalRequest.writableFinished && headers.accept === undefined) {\n      headers.accept = 'application/json';\n    }\n    return shortcut('json');\n  };\n  promise.buffer = () => shortcut('buffer');\n  promise.text = () => shortcut('text');\n  return promise;\n}\nexports.default = asPromise;\n__exportStar(require(\"./types\"), exports);","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__exportStar","exports","p","prototype","hasOwnProperty","call","value","events_1","require","is_1","PCancelable","types_1","parse_body_1","core_1","proxy_events_1","get_buffer_1","is_response_ok_1","proxiedRequestEvents","asPromise","normalizedOptions","globalRequest","globalResponse","emitter","EventEmitter","promise","resolve","reject","onCancel","makeRequest","retryCount","request","default","_noPipe","destroy","shouldReject","CancelError","once","response","_a","aborted","rawBody","_b","_isAboutToError","contentEncoding","headers","toLowerCase","isCompressed","includes","options","decompress","body","responseType","parseJson","encoding","error","toString","isResponseOk","_beforeError","index","hook","hooks","afterResponse","entries","updatedOptions","typedOptions","normalizeArguments","retry","calculateDelay","throwHttpErrors","resolveBodyOnly","slice","beforeRetry","catch","cancel","RequestError","message","HTTPError","onError","isCanceled","previousBody","newRetryCount","nodeStream","on","event","fn","shortcut","newPromise","defineProperties","getOwnPropertyDescriptors","json","writableFinished","accept","buffer","text"],"sources":["/home/spartan/Documents/vue.js/demo/node_modules/got/dist/source/as-promise/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst is_1 = require(\"@sindresorhus/is\");\nconst PCancelable = require(\"p-cancelable\");\nconst types_1 = require(\"./types\");\nconst parse_body_1 = require(\"./parse-body\");\nconst core_1 = require(\"../core\");\nconst proxy_events_1 = require(\"../core/utils/proxy-events\");\nconst get_buffer_1 = require(\"../core/utils/get-buffer\");\nconst is_response_ok_1 = require(\"../core/utils/is-response-ok\");\nconst proxiedRequestEvents = [\n    'request',\n    'response',\n    'redirect',\n    'uploadProgress',\n    'downloadProgress'\n];\nfunction asPromise(normalizedOptions) {\n    let globalRequest;\n    let globalResponse;\n    const emitter = new events_1.EventEmitter();\n    const promise = new PCancelable((resolve, reject, onCancel) => {\n        const makeRequest = (retryCount) => {\n            const request = new core_1.default(undefined, normalizedOptions);\n            request.retryCount = retryCount;\n            request._noPipe = true;\n            onCancel(() => request.destroy());\n            onCancel.shouldReject = false;\n            onCancel(() => reject(new types_1.CancelError(request)));\n            globalRequest = request;\n            request.once('response', async (response) => {\n                var _a;\n                response.retryCount = retryCount;\n                if (response.request.aborted) {\n                    // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error\n                    return;\n                }\n                // Download body\n                let rawBody;\n                try {\n                    rawBody = await get_buffer_1.default(request);\n                    response.rawBody = rawBody;\n                }\n                catch (_b) {\n                    // The same error is caught below.\n                    // See request.once('error')\n                    return;\n                }\n                if (request._isAboutToError) {\n                    return;\n                }\n                // Parse body\n                const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();\n                const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);\n                const { options } = request;\n                if (isCompressed && !options.decompress) {\n                    response.body = rawBody;\n                }\n                else {\n                    try {\n                        response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);\n                    }\n                    catch (error) {\n                        // Fallback to `utf8`\n                        response.body = rawBody.toString();\n                        if (is_response_ok_1.isResponseOk(response)) {\n                            request._beforeError(error);\n                            return;\n                        }\n                    }\n                }\n                try {\n                    for (const [index, hook] of options.hooks.afterResponse.entries()) {\n                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n                        // eslint-disable-next-line no-await-in-loop\n                        response = await hook(response, async (updatedOptions) => {\n                            const typedOptions = core_1.default.normalizeArguments(undefined, {\n                                ...updatedOptions,\n                                retry: {\n                                    calculateDelay: () => 0\n                                },\n                                throwHttpErrors: false,\n                                resolveBodyOnly: false\n                            }, options);\n                            // Remove any further hooks for that request, because we'll call them anyway.\n                            // The loop continues. We don't want duplicates (asPromise recursion).\n                            typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);\n                            for (const hook of typedOptions.hooks.beforeRetry) {\n                                // eslint-disable-next-line no-await-in-loop\n                                await hook(typedOptions);\n                            }\n                            const promise = asPromise(typedOptions);\n                            onCancel(() => {\n                                promise.catch(() => { });\n                                promise.cancel();\n                            });\n                            return promise;\n                        });\n                    }\n                }\n                catch (error) {\n                    request._beforeError(new types_1.RequestError(error.message, error, request));\n                    return;\n                }\n                globalResponse = response;\n                if (!is_response_ok_1.isResponseOk(response)) {\n                    request._beforeError(new types_1.HTTPError(response));\n                    return;\n                }\n                request.destroy();\n                resolve(request.options.resolveBodyOnly ? response.body : response);\n            });\n            const onError = (error) => {\n                if (promise.isCanceled) {\n                    return;\n                }\n                const { options } = request;\n                if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {\n                    const { response } = error;\n                    resolve(request.options.resolveBodyOnly ? response.body : response);\n                    return;\n                }\n                reject(error);\n            };\n            request.once('error', onError);\n            const previousBody = request.options.body;\n            request.once('retry', (newRetryCount, error) => {\n                var _a, _b;\n                if (previousBody === ((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body) && is_1.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {\n                    onError(error);\n                    return;\n                }\n                makeRequest(newRetryCount);\n            });\n            proxy_events_1.default(request, emitter, proxiedRequestEvents);\n        };\n        makeRequest(0);\n    });\n    promise.on = (event, fn) => {\n        emitter.on(event, fn);\n        return promise;\n    };\n    const shortcut = (responseType) => {\n        const newPromise = (async () => {\n            // Wait until downloading has ended\n            await promise;\n            const { options } = globalResponse.request;\n            return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);\n        })();\n        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n        return newPromise;\n    };\n    promise.json = () => {\n        const { headers } = globalRequest.options;\n        if (!globalRequest.writableFinished && headers.accept === undefined) {\n            headers.accept = 'application/json';\n        }\n        return shortcut('json');\n    };\n    promise.buffer = () => shortcut('buffer');\n    promise.text = () => shortcut('text');\n    return promise;\n}\nexports.default = asPromise;\n__exportStar(require(\"./types\"), exports);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}