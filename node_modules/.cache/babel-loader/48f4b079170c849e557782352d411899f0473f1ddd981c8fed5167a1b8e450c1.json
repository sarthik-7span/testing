{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst EventEmitter = require('events');\nconst tls = require('tls');\nconst http2 = require('http2');\nconst QuickLRU = require('quick-lru');\nconst kCurrentStreamsCount = Symbol('currentStreamsCount');\nconst kRequest = Symbol('request');\nconst kOriginSet = Symbol('cachedOriginSet');\nconst kGracefullyClosing = Symbol('gracefullyClosing');\nconst nameKeys = [\n// `http2.connect()` options\n'maxDeflateDynamicTableSize', 'maxSessionMemory', 'maxHeaderListPairs', 'maxOutstandingPings', 'maxReservedRemoteStreams', 'maxSendHeaderBlockLength', 'paddingStrategy',\n// `tls.connect()` options\n'localAddress', 'path', 'rejectUnauthorized', 'minDHSize',\n// `tls.createSecureContext()` options\n'ca', 'cert', 'clientCertEngine', 'ciphers', 'key', 'pfx', 'servername', 'minVersion', 'maxVersion', 'secureProtocol', 'crl', 'honorCipherOrder', 'ecdhCurve', 'dhparam', 'secureOptions', 'sessionIdContext'];\nconst getSortedIndex = (array, value, compare) => {\n  let low = 0;\n  let high = array.length;\n  while (low < high) {\n    const mid = low + high >>> 1;\n\n    /* istanbul ignore next */\n    if (compare(array[mid], value)) {\n      // This never gets called because we use descending sort. Better to have this anyway.\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n};\nconst compareSessions = (a, b) => {\n  return a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;\n};\n\n// See https://tools.ietf.org/html/rfc8336\nconst closeCoveredSessions = (where, session) => {\n  // Clients SHOULD NOT emit new requests on any connection whose Origin\n  // Set is a proper subset of another connection's Origin Set, and they\n  // SHOULD close it once all outstanding requests are satisfied.\n  for (const coveredSession of where) {\n    if (\n    // The set is a proper subset when its length is less than the other set.\n    coveredSession[kOriginSet].length < session[kOriginSet].length &&\n    // And the other set includes all elements of the subset.\n    coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&\n    // Makes sure that the session can handle all requests from the covered session.\n    coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {\n      // This allows pending requests to finish and prevents making new requests.\n      gracefullyClose(coveredSession);\n    }\n  }\n};\n\n// This is basically inverted `closeCoveredSessions(...)`.\nconst closeSessionIfCovered = (where, coveredSession) => {\n  for (const session of where) {\n    if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {\n      gracefullyClose(coveredSession);\n    }\n  }\n};\nconst getSessions = ({\n  agent,\n  isFree\n}) => {\n  const result = {};\n\n  // eslint-disable-next-line guard-for-in\n  for (const normalizedOptions in agent.sessions) {\n    const sessions = agent.sessions[normalizedOptions];\n    const filtered = sessions.filter(session => {\n      const result = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n      return isFree ? result : !result;\n    });\n    if (filtered.length !== 0) {\n      result[normalizedOptions] = filtered;\n    }\n  }\n  return result;\n};\nconst gracefullyClose = session => {\n  session[kGracefullyClosing] = true;\n  if (session[kCurrentStreamsCount] === 0) {\n    session.close();\n  }\n};\nclass Agent extends EventEmitter {\n  constructor({\n    timeout = 60000,\n    maxSessions = Infinity,\n    maxFreeSessions = 10,\n    maxCachedTlsSessions = 100\n  } = {}) {\n    super();\n\n    // A session is considered busy when its current streams count\n    // is equal to or greater than the `maxConcurrentStreams` value.\n\n    // A session is considered free when its current streams count\n    // is less than the `maxConcurrentStreams` value.\n\n    // SESSIONS[NORMALIZED_OPTIONS] = [];\n    this.sessions = {};\n\n    // The queue for creating new sessions. It looks like this:\n    // QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION\n    //\n    // The entry function has `listeners`, `completed` and `destroyed` properties.\n    // `listeners` is an array of objects containing `resolve` and `reject` functions.\n    // `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.\n    // `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.\n    this.queue = {};\n\n    // Each session will use this timeout value.\n    this.timeout = timeout;\n\n    // Max sessions in total\n    this.maxSessions = maxSessions;\n\n    // Max free sessions in total\n    // TODO: decreasing `maxFreeSessions` should close some sessions\n    this.maxFreeSessions = maxFreeSessions;\n    this._freeSessionsCount = 0;\n    this._sessionsCount = 0;\n\n    // We don't support push streams by default.\n    this.settings = {\n      enablePush: false\n    };\n\n    // Reusing TLS sessions increases performance.\n    this.tlsSessionCache = new QuickLRU({\n      maxSize: maxCachedTlsSessions\n    });\n  }\n  static normalizeOrigin(url, servername) {\n    if (typeof url === 'string') {\n      url = new URL(url);\n    }\n    if (servername && url.hostname !== servername) {\n      url.hostname = servername;\n    }\n    return url.origin;\n  }\n  normalizeOptions(options) {\n    let normalized = '';\n    if (options) {\n      for (const key of nameKeys) {\n        if (options[key]) {\n          normalized += `:${options[key]}`;\n        }\n      }\n    }\n    return normalized;\n  }\n  _tryToCreateNewSession(normalizedOptions, normalizedOrigin) {\n    if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {\n      return;\n    }\n    const item = this.queue[normalizedOptions][normalizedOrigin];\n\n    // The entry function can be run only once.\n    // BUG: The session may be never created when:\n    // - the first condition is false AND\n    // - this function is never called with the same arguments in the future.\n    if (this._sessionsCount < this.maxSessions && !item.completed) {\n      item.completed = true;\n      item();\n    }\n  }\n  getSession(origin, options, listeners) {\n    return new Promise((resolve, reject) => {\n      if (Array.isArray(listeners)) {\n        listeners = [...listeners];\n\n        // Resolve the current promise ASAP, we're just moving the listeners.\n        // They will be executed at a different time.\n        resolve();\n      } else {\n        listeners = [{\n          resolve,\n          reject\n        }];\n      }\n      const normalizedOptions = this.normalizeOptions(options);\n      const normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);\n      if (normalizedOrigin === undefined) {\n        for (const {\n          reject\n        } of listeners) {\n          reject(new TypeError('The `origin` argument needs to be a string or an URL object'));\n        }\n        return;\n      }\n      if (normalizedOptions in this.sessions) {\n        const sessions = this.sessions[normalizedOptions];\n        let maxConcurrentStreams = -1;\n        let currentStreamsCount = -1;\n        let optimalSession;\n\n        // We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.\n        // Additionally, we are looking for session which has biggest current pending streams count.\n        for (const session of sessions) {\n          const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;\n          if (sessionMaxConcurrentStreams < maxConcurrentStreams) {\n            break;\n          }\n          if (session[kOriginSet].includes(normalizedOrigin)) {\n            const sessionCurrentStreamsCount = session[kCurrentStreamsCount];\n            if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] ||\n            // Unfortunately the `close` event isn't called immediately,\n            // so `session.destroyed` is `true`, but `session.closed` is `false`.\n            session.destroyed) {\n              continue;\n            }\n\n            // We only need set this once.\n            if (!optimalSession) {\n              maxConcurrentStreams = sessionMaxConcurrentStreams;\n            }\n\n            // We're looking for the session which has biggest current pending stream count,\n            // in order to minimalize the amount of active sessions.\n            if (sessionCurrentStreamsCount > currentStreamsCount) {\n              optimalSession = session;\n              currentStreamsCount = sessionCurrentStreamsCount;\n            }\n          }\n        }\n        if (optimalSession) {\n          /* istanbul ignore next: safety check */\n          if (listeners.length !== 1) {\n            for (const {\n              reject\n            } of listeners) {\n              const error = new Error(`Expected the length of listeners to be 1, got ${listeners.length}.\\n` + 'Please report this to https://github.com/szmarczak/http2-wrapper/');\n              reject(error);\n            }\n            return;\n          }\n          listeners[0].resolve(optimalSession);\n          return;\n        }\n      }\n      if (normalizedOptions in this.queue) {\n        if (normalizedOrigin in this.queue[normalizedOptions]) {\n          // There's already an item in the queue, just attach ourselves to it.\n          this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);\n\n          // This shouldn't be executed here.\n          // See the comment inside _tryToCreateNewSession.\n          this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n          return;\n        }\n      } else {\n        this.queue[normalizedOptions] = {};\n      }\n\n      // The entry must be removed from the queue IMMEDIATELY when:\n      // 1. the session connects successfully,\n      // 2. an error occurs.\n      const removeFromQueue = () => {\n        // Our entry can be replaced. We cannot remove the new one.\n        if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {\n          delete this.queue[normalizedOptions][normalizedOrigin];\n          if (Object.keys(this.queue[normalizedOptions]).length === 0) {\n            delete this.queue[normalizedOptions];\n          }\n        }\n      };\n\n      // The main logic is here\n      const entry = () => {\n        const name = `${normalizedOrigin}:${normalizedOptions}`;\n        let receivedSettings = false;\n        try {\n          const session = http2.connect(origin, {\n            createConnection: this.createConnection,\n            settings: this.settings,\n            session: this.tlsSessionCache.get(name),\n            ...options\n          });\n          session[kCurrentStreamsCount] = 0;\n          session[kGracefullyClosing] = false;\n          const isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n          let wasFree = true;\n          session.socket.once('session', tlsSession => {\n            this.tlsSessionCache.set(name, tlsSession);\n          });\n          session.once('error', error => {\n            // Listeners are empty when the session successfully connected.\n            for (const {\n              reject\n            } of listeners) {\n              reject(error);\n            }\n\n            // The connection got broken, purge the cache.\n            this.tlsSessionCache.delete(name);\n          });\n          session.setTimeout(this.timeout, () => {\n            // Terminates all streams owned by this session.\n            // TODO: Maybe the streams should have a \"Session timed out\" error?\n            session.destroy();\n          });\n          session.once('close', () => {\n            if (receivedSettings) {\n              // 1. If it wasn't free then no need to decrease because\n              //    it has been decreased already in session.request().\n              // 2. `stream.once('close')` won't increment the count\n              //    because the session is already closed.\n              if (wasFree) {\n                this._freeSessionsCount--;\n              }\n              this._sessionsCount--;\n\n              // This cannot be moved to the stream logic,\n              // because there may be a session that hadn't made a single request.\n              const where = this.sessions[normalizedOptions];\n              where.splice(where.indexOf(session), 1);\n              if (where.length === 0) {\n                delete this.sessions[normalizedOptions];\n              }\n            } else {\n              // Broken connection\n              const error = new Error('Session closed without receiving a SETTINGS frame');\n              error.code = 'HTTP2WRAPPER_NOSETTINGS';\n              for (const {\n                reject\n              } of listeners) {\n                reject(error);\n              }\n              removeFromQueue();\n            }\n\n            // There may be another session awaiting.\n            this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n          });\n\n          // Iterates over the queue and processes listeners.\n          const processListeners = () => {\n            if (!(normalizedOptions in this.queue) || !isFree()) {\n              return;\n            }\n            for (const origin of session[kOriginSet]) {\n              if (origin in this.queue[normalizedOptions]) {\n                const {\n                  listeners\n                } = this.queue[normalizedOptions][origin];\n\n                // Prevents session overloading.\n                while (listeners.length !== 0 && isFree()) {\n                  // We assume `resolve(...)` calls `request(...)` *directly*,\n                  // otherwise the session will get overloaded.\n                  listeners.shift().resolve(session);\n                }\n                const where = this.queue[normalizedOptions];\n                if (where[origin].listeners.length === 0) {\n                  delete where[origin];\n                  if (Object.keys(where).length === 0) {\n                    delete this.queue[normalizedOptions];\n                    break;\n                  }\n                }\n\n                // We're no longer free, no point in continuing.\n                if (!isFree()) {\n                  break;\n                }\n              }\n            }\n          };\n\n          // The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.\n          session.on('origin', () => {\n            session[kOriginSet] = session.originSet;\n            if (!isFree()) {\n              // The session is full.\n              return;\n            }\n            processListeners();\n\n            // Close covered sessions (if possible).\n            closeCoveredSessions(this.sessions[normalizedOptions], session);\n          });\n          session.once('remoteSettings', () => {\n            // Fix Node.js bug preventing the process from exiting\n            session.ref();\n            session.unref();\n            this._sessionsCount++;\n\n            // The Agent could have been destroyed already.\n            if (entry.destroyed) {\n              const error = new Error('Agent has been destroyed');\n              for (const listener of listeners) {\n                listener.reject(error);\n              }\n              session.destroy();\n              return;\n            }\n            session[kOriginSet] = session.originSet;\n            {\n              const where = this.sessions;\n              if (normalizedOptions in where) {\n                const sessions = where[normalizedOptions];\n                sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);\n              } else {\n                where[normalizedOptions] = [session];\n              }\n            }\n            this._freeSessionsCount += 1;\n            receivedSettings = true;\n            this.emit('session', session);\n            processListeners();\n            removeFromQueue();\n\n            // TODO: Close last recently used (or least used?) session\n            if (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {\n              session.close();\n            }\n\n            // Check if we haven't managed to execute all listeners.\n            if (listeners.length !== 0) {\n              // Request for a new session with predefined listeners.\n              this.getSession(normalizedOrigin, options, listeners);\n              listeners.length = 0;\n            }\n\n            // `session.remoteSettings.maxConcurrentStreams` might get increased\n            session.on('remoteSettings', () => {\n              processListeners();\n\n              // In case the Origin Set changes\n              closeCoveredSessions(this.sessions[normalizedOptions], session);\n            });\n          });\n\n          // Shim `session.request()` in order to catch all streams\n          session[kRequest] = session.request;\n          session.request = (headers, streamOptions) => {\n            if (session[kGracefullyClosing]) {\n              throw new Error('The session is gracefully closing. No new streams are allowed.');\n            }\n            const stream = session[kRequest](headers, streamOptions);\n\n            // The process won't exit until the session is closed or all requests are gone.\n            session.ref();\n            ++session[kCurrentStreamsCount];\n            if (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {\n              this._freeSessionsCount--;\n            }\n            stream.once('close', () => {\n              wasFree = isFree();\n              --session[kCurrentStreamsCount];\n              if (!session.destroyed && !session.closed) {\n                closeSessionIfCovered(this.sessions[normalizedOptions], session);\n                if (isFree() && !session.closed) {\n                  if (!wasFree) {\n                    this._freeSessionsCount++;\n                    wasFree = true;\n                  }\n                  const isEmpty = session[kCurrentStreamsCount] === 0;\n                  if (isEmpty) {\n                    session.unref();\n                  }\n                  if (isEmpty && (this._freeSessionsCount > this.maxFreeSessions || session[kGracefullyClosing])) {\n                    session.close();\n                  } else {\n                    closeCoveredSessions(this.sessions[normalizedOptions], session);\n                    processListeners();\n                  }\n                }\n              }\n            });\n            return stream;\n          };\n        } catch (error) {\n          for (const listener of listeners) {\n            listener.reject(error);\n          }\n          removeFromQueue();\n        }\n      };\n      entry.listeners = listeners;\n      entry.completed = false;\n      entry.destroyed = false;\n      this.queue[normalizedOptions][normalizedOrigin] = entry;\n      this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n    });\n  }\n  request(origin, options, headers, streamOptions) {\n    return new Promise((resolve, reject) => {\n      this.getSession(origin, options, [{\n        reject,\n        resolve: session => {\n          try {\n            resolve(session.request(headers, streamOptions));\n          } catch (error) {\n            reject(error);\n          }\n        }\n      }]);\n    });\n  }\n  createConnection(origin, options) {\n    return Agent.connect(origin, options);\n  }\n  static connect(origin, options) {\n    options.ALPNProtocols = ['h2'];\n    const port = origin.port || 443;\n    const host = origin.hostname || origin.host;\n    if (typeof options.servername === 'undefined') {\n      options.servername = host;\n    }\n    return tls.connect(port, host, options);\n  }\n  closeFreeSessions() {\n    for (const sessions of Object.values(this.sessions)) {\n      for (const session of sessions) {\n        if (session[kCurrentStreamsCount] === 0) {\n          session.close();\n        }\n      }\n    }\n  }\n  destroy(reason) {\n    for (const sessions of Object.values(this.sessions)) {\n      for (const session of sessions) {\n        session.destroy(reason);\n      }\n    }\n    for (const entriesOfAuthority of Object.values(this.queue)) {\n      for (const entry of Object.values(entriesOfAuthority)) {\n        entry.destroyed = true;\n      }\n    }\n\n    // New requests should NOT attach to destroyed sessions\n    this.queue = {};\n  }\n  get freeSessions() {\n    return getSessions({\n      agent: this,\n      isFree: true\n    });\n  }\n  get busySessions() {\n    return getSessions({\n      agent: this,\n      isFree: false\n    });\n  }\n}\nAgent.kCurrentStreamsCount = kCurrentStreamsCount;\nAgent.kGracefullyClosing = kGracefullyClosing;\nmodule.exports = {\n  Agent,\n  globalAgent: new Agent()\n};","map":{"version":3,"names":["EventEmitter","require","tls","http2","QuickLRU","kCurrentStreamsCount","Symbol","kRequest","kOriginSet","kGracefullyClosing","nameKeys","getSortedIndex","array","value","compare","low","high","length","mid","compareSessions","a","b","remoteSettings","maxConcurrentStreams","closeCoveredSessions","where","session","coveredSession","every","origin","includes","gracefullyClose","closeSessionIfCovered","getSessions","agent","isFree","result","normalizedOptions","sessions","filtered","filter","Agent","close","constructor","timeout","maxSessions","Infinity","maxFreeSessions","maxCachedTlsSessions","queue","_freeSessionsCount","_sessionsCount","settings","enablePush","tlsSessionCache","maxSize","normalizeOrigin","url","servername","URL","hostname","normalizeOptions","options","normalized","key","_tryToCreateNewSession","normalizedOrigin","item","completed","getSession","listeners","Promise","resolve","reject","Array","isArray","undefined","TypeError","currentStreamsCount","optimalSession","sessionMaxConcurrentStreams","sessionCurrentStreamsCount","destroyed","error","Error","push","removeFromQueue","entry","Object","keys","name","receivedSettings","connect","createConnection","get","wasFree","socket","once","tlsSession","set","delete","setTimeout","destroy","splice","indexOf","code","processListeners","shift","on","originSet","ref","unref","listener","emit","request","headers","streamOptions","stream","closed","isEmpty","ALPNProtocols","port","host","closeFreeSessions","values","reason","entriesOfAuthority","freeSessions","busySessions","module","exports","globalAgent"],"sources":["/home/spartan/Documents/vue.js/demo/node_modules/http2-wrapper/source/agent.js"],"sourcesContent":["'use strict';\nconst EventEmitter = require('events');\nconst tls = require('tls');\nconst http2 = require('http2');\nconst QuickLRU = require('quick-lru');\n\nconst kCurrentStreamsCount = Symbol('currentStreamsCount');\nconst kRequest = Symbol('request');\nconst kOriginSet = Symbol('cachedOriginSet');\nconst kGracefullyClosing = Symbol('gracefullyClosing');\n\nconst nameKeys = [\n\t// `http2.connect()` options\n\t'maxDeflateDynamicTableSize',\n\t'maxSessionMemory',\n\t'maxHeaderListPairs',\n\t'maxOutstandingPings',\n\t'maxReservedRemoteStreams',\n\t'maxSendHeaderBlockLength',\n\t'paddingStrategy',\n\n\t// `tls.connect()` options\n\t'localAddress',\n\t'path',\n\t'rejectUnauthorized',\n\t'minDHSize',\n\n\t// `tls.createSecureContext()` options\n\t'ca',\n\t'cert',\n\t'clientCertEngine',\n\t'ciphers',\n\t'key',\n\t'pfx',\n\t'servername',\n\t'minVersion',\n\t'maxVersion',\n\t'secureProtocol',\n\t'crl',\n\t'honorCipherOrder',\n\t'ecdhCurve',\n\t'dhparam',\n\t'secureOptions',\n\t'sessionIdContext'\n];\n\nconst getSortedIndex = (array, value, compare) => {\n\tlet low = 0;\n\tlet high = array.length;\n\n\twhile (low < high) {\n\t\tconst mid = (low + high) >>> 1;\n\n\t\t/* istanbul ignore next */\n\t\tif (compare(array[mid], value)) {\n\t\t\t// This never gets called because we use descending sort. Better to have this anyway.\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\n\treturn low;\n};\n\nconst compareSessions = (a, b) => {\n\treturn a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;\n};\n\n// See https://tools.ietf.org/html/rfc8336\nconst closeCoveredSessions = (where, session) => {\n\t// Clients SHOULD NOT emit new requests on any connection whose Origin\n\t// Set is a proper subset of another connection's Origin Set, and they\n\t// SHOULD close it once all outstanding requests are satisfied.\n\tfor (const coveredSession of where) {\n\t\tif (\n\t\t\t// The set is a proper subset when its length is less than the other set.\n\t\t\tcoveredSession[kOriginSet].length < session[kOriginSet].length &&\n\n\t\t\t// And the other set includes all elements of the subset.\n\t\t\tcoveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&\n\n\t\t\t// Makes sure that the session can handle all requests from the covered session.\n\t\t\tcoveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\t// This allows pending requests to finish and prevents making new requests.\n\t\t\tgracefullyClose(coveredSession);\n\t\t}\n\t}\n};\n\n// This is basically inverted `closeCoveredSessions(...)`.\nconst closeSessionIfCovered = (where, coveredSession) => {\n\tfor (const session of where) {\n\t\tif (\n\t\t\tcoveredSession[kOriginSet].length < session[kOriginSet].length &&\n\t\t\tcoveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&\n\t\t\tcoveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\tgracefullyClose(coveredSession);\n\t\t}\n\t}\n};\n\nconst getSessions = ({agent, isFree}) => {\n\tconst result = {};\n\n\t// eslint-disable-next-line guard-for-in\n\tfor (const normalizedOptions in agent.sessions) {\n\t\tconst sessions = agent.sessions[normalizedOptions];\n\n\t\tconst filtered = sessions.filter(session => {\n\t\t\tconst result = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n\n\t\t\treturn isFree ? result : !result;\n\t\t});\n\n\t\tif (filtered.length !== 0) {\n\t\t\tresult[normalizedOptions] = filtered;\n\t\t}\n\t}\n\n\treturn result;\n};\n\nconst gracefullyClose = session => {\n\tsession[kGracefullyClosing] = true;\n\n\tif (session[kCurrentStreamsCount] === 0) {\n\t\tsession.close();\n\t}\n};\n\nclass Agent extends EventEmitter {\n\tconstructor({timeout = 60000, maxSessions = Infinity, maxFreeSessions = 10, maxCachedTlsSessions = 100} = {}) {\n\t\tsuper();\n\n\t\t// A session is considered busy when its current streams count\n\t\t// is equal to or greater than the `maxConcurrentStreams` value.\n\n\t\t// A session is considered free when its current streams count\n\t\t// is less than the `maxConcurrentStreams` value.\n\n\t\t// SESSIONS[NORMALIZED_OPTIONS] = [];\n\t\tthis.sessions = {};\n\n\t\t// The queue for creating new sessions. It looks like this:\n\t\t// QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION\n\t\t//\n\t\t// The entry function has `listeners`, `completed` and `destroyed` properties.\n\t\t// `listeners` is an array of objects containing `resolve` and `reject` functions.\n\t\t// `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.\n\t\t// `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.\n\t\tthis.queue = {};\n\n\t\t// Each session will use this timeout value.\n\t\tthis.timeout = timeout;\n\n\t\t// Max sessions in total\n\t\tthis.maxSessions = maxSessions;\n\n\t\t// Max free sessions in total\n\t\t// TODO: decreasing `maxFreeSessions` should close some sessions\n\t\tthis.maxFreeSessions = maxFreeSessions;\n\n\t\tthis._freeSessionsCount = 0;\n\t\tthis._sessionsCount = 0;\n\n\t\t// We don't support push streams by default.\n\t\tthis.settings = {\n\t\t\tenablePush: false\n\t\t};\n\n\t\t// Reusing TLS sessions increases performance.\n\t\tthis.tlsSessionCache = new QuickLRU({maxSize: maxCachedTlsSessions});\n\t}\n\n\tstatic normalizeOrigin(url, servername) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = new URL(url);\n\t\t}\n\n\t\tif (servername && url.hostname !== servername) {\n\t\t\turl.hostname = servername;\n\t\t}\n\n\t\treturn url.origin;\n\t}\n\n\tnormalizeOptions(options) {\n\t\tlet normalized = '';\n\n\t\tif (options) {\n\t\t\tfor (const key of nameKeys) {\n\t\t\t\tif (options[key]) {\n\t\t\t\t\tnormalized += `:${options[key]}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn normalized;\n\t}\n\n\t_tryToCreateNewSession(normalizedOptions, normalizedOrigin) {\n\t\tif (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst item = this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t// The entry function can be run only once.\n\t\t// BUG: The session may be never created when:\n\t\t// - the first condition is false AND\n\t\t// - this function is never called with the same arguments in the future.\n\t\tif (this._sessionsCount < this.maxSessions && !item.completed) {\n\t\t\titem.completed = true;\n\n\t\t\titem();\n\t\t}\n\t}\n\n\tgetSession(origin, options, listeners) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (Array.isArray(listeners)) {\n\t\t\t\tlisteners = [...listeners];\n\n\t\t\t\t// Resolve the current promise ASAP, we're just moving the listeners.\n\t\t\t\t// They will be executed at a different time.\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\tlisteners = [{resolve, reject}];\n\t\t\t}\n\n\t\t\tconst normalizedOptions = this.normalizeOptions(options);\n\t\t\tconst normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);\n\n\t\t\tif (normalizedOrigin === undefined) {\n\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\treject(new TypeError('The `origin` argument needs to be a string or an URL object'));\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (normalizedOptions in this.sessions) {\n\t\t\t\tconst sessions = this.sessions[normalizedOptions];\n\n\t\t\t\tlet maxConcurrentStreams = -1;\n\t\t\t\tlet currentStreamsCount = -1;\n\t\t\t\tlet optimalSession;\n\n\t\t\t\t// We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.\n\t\t\t\t// Additionally, we are looking for session which has biggest current pending streams count.\n\t\t\t\tfor (const session of sessions) {\n\t\t\t\t\tconst sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;\n\n\t\t\t\t\tif (sessionMaxConcurrentStreams < maxConcurrentStreams) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (session[kOriginSet].includes(normalizedOrigin)) {\n\t\t\t\t\t\tconst sessionCurrentStreamsCount = session[kCurrentStreamsCount];\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tsessionCurrentStreamsCount >= sessionMaxConcurrentStreams ||\n\t\t\t\t\t\t\tsession[kGracefullyClosing] ||\n\t\t\t\t\t\t\t// Unfortunately the `close` event isn't called immediately,\n\t\t\t\t\t\t\t// so `session.destroyed` is `true`, but `session.closed` is `false`.\n\t\t\t\t\t\t\tsession.destroyed\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We only need set this once.\n\t\t\t\t\t\tif (!optimalSession) {\n\t\t\t\t\t\t\tmaxConcurrentStreams = sessionMaxConcurrentStreams;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We're looking for the session which has biggest current pending stream count,\n\t\t\t\t\t\t// in order to minimalize the amount of active sessions.\n\t\t\t\t\t\tif (sessionCurrentStreamsCount > currentStreamsCount) {\n\t\t\t\t\t\t\toptimalSession = session;\n\t\t\t\t\t\t\tcurrentStreamsCount = sessionCurrentStreamsCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (optimalSession) {\n\t\t\t\t\t/* istanbul ignore next: safety check */\n\t\t\t\t\tif (listeners.length !== 1) {\n\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\tconst error = new Error(\n\t\t\t\t\t\t\t\t`Expected the length of listeners to be 1, got ${listeners.length}.\\n` +\n\t\t\t\t\t\t\t\t'Please report this to https://github.com/szmarczak/http2-wrapper/'\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlisteners[0].resolve(optimalSession);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (normalizedOptions in this.queue) {\n\t\t\t\tif (normalizedOrigin in this.queue[normalizedOptions]) {\n\t\t\t\t\t// There's already an item in the queue, just attach ourselves to it.\n\t\t\t\t\tthis.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);\n\n\t\t\t\t\t// This shouldn't be executed here.\n\t\t\t\t\t// See the comment inside _tryToCreateNewSession.\n\t\t\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.queue[normalizedOptions] = {};\n\t\t\t}\n\n\t\t\t// The entry must be removed from the queue IMMEDIATELY when:\n\t\t\t// 1. the session connects successfully,\n\t\t\t// 2. an error occurs.\n\t\t\tconst removeFromQueue = () => {\n\t\t\t\t// Our entry can be replaced. We cannot remove the new one.\n\t\t\t\tif (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {\n\t\t\t\t\tdelete this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t\t\t\tif (Object.keys(this.queue[normalizedOptions]).length === 0) {\n\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// The main logic is here\n\t\t\tconst entry = () => {\n\t\t\t\tconst name = `${normalizedOrigin}:${normalizedOptions}`;\n\t\t\t\tlet receivedSettings = false;\n\n\t\t\t\ttry {\n\t\t\t\t\tconst session = http2.connect(origin, {\n\t\t\t\t\t\tcreateConnection: this.createConnection,\n\t\t\t\t\t\tsettings: this.settings,\n\t\t\t\t\t\tsession: this.tlsSessionCache.get(name),\n\t\t\t\t\t\t...options\n\t\t\t\t\t});\n\t\t\t\t\tsession[kCurrentStreamsCount] = 0;\n\t\t\t\t\tsession[kGracefullyClosing] = false;\n\n\t\t\t\t\tconst isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n\t\t\t\t\tlet wasFree = true;\n\n\t\t\t\t\tsession.socket.once('session', tlsSession => {\n\t\t\t\t\t\tthis.tlsSessionCache.set(name, tlsSession);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('error', error => {\n\t\t\t\t\t\t// Listeners are empty when the session successfully connected.\n\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The connection got broken, purge the cache.\n\t\t\t\t\t\tthis.tlsSessionCache.delete(name);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.setTimeout(this.timeout, () => {\n\t\t\t\t\t\t// Terminates all streams owned by this session.\n\t\t\t\t\t\t// TODO: Maybe the streams should have a \"Session timed out\" error?\n\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('close', () => {\n\t\t\t\t\t\tif (receivedSettings) {\n\t\t\t\t\t\t\t// 1. If it wasn't free then no need to decrease because\n\t\t\t\t\t\t\t//    it has been decreased already in session.request().\n\t\t\t\t\t\t\t// 2. `stream.once('close')` won't increment the count\n\t\t\t\t\t\t\t//    because the session is already closed.\n\t\t\t\t\t\t\tif (wasFree) {\n\t\t\t\t\t\t\t\tthis._freeSessionsCount--;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._sessionsCount--;\n\n\t\t\t\t\t\t\t// This cannot be moved to the stream logic,\n\t\t\t\t\t\t\t// because there may be a session that hadn't made a single request.\n\t\t\t\t\t\t\tconst where = this.sessions[normalizedOptions];\n\t\t\t\t\t\t\twhere.splice(where.indexOf(session), 1);\n\n\t\t\t\t\t\t\tif (where.length === 0) {\n\t\t\t\t\t\t\t\tdelete this.sessions[normalizedOptions];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Broken connection\n\t\t\t\t\t\t\tconst error = new Error('Session closed without receiving a SETTINGS frame');\n\t\t\t\t\t\t\terror.code = 'HTTP2WRAPPER_NOSETTINGS';\n\n\t\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tremoveFromQueue();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// There may be another session awaiting.\n\t\t\t\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t\t\t\t});\n\n\t\t\t\t\t// Iterates over the queue and processes listeners.\n\t\t\t\t\tconst processListeners = () => {\n\t\t\t\t\t\tif (!(normalizedOptions in this.queue) || !isFree()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const origin of session[kOriginSet]) {\n\t\t\t\t\t\t\tif (origin in this.queue[normalizedOptions]) {\n\t\t\t\t\t\t\t\tconst {listeners} = this.queue[normalizedOptions][origin];\n\n\t\t\t\t\t\t\t\t// Prevents session overloading.\n\t\t\t\t\t\t\t\twhile (listeners.length !== 0 && isFree()) {\n\t\t\t\t\t\t\t\t\t// We assume `resolve(...)` calls `request(...)` *directly*,\n\t\t\t\t\t\t\t\t\t// otherwise the session will get overloaded.\n\t\t\t\t\t\t\t\t\tlisteners.shift().resolve(session);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst where = this.queue[normalizedOptions];\n\t\t\t\t\t\t\t\tif (where[origin].listeners.length === 0) {\n\t\t\t\t\t\t\t\t\tdelete where[origin];\n\n\t\t\t\t\t\t\t\t\tif (Object.keys(where).length === 0) {\n\t\t\t\t\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// We're no longer free, no point in continuing.\n\t\t\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.\n\t\t\t\t\tsession.on('origin', () => {\n\t\t\t\t\t\tsession[kOriginSet] = session.originSet;\n\n\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t// The session is full.\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t// Close covered sessions (if possible).\n\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('remoteSettings', () => {\n\t\t\t\t\t\t// Fix Node.js bug preventing the process from exiting\n\t\t\t\t\t\tsession.ref();\n\t\t\t\t\t\tsession.unref();\n\n\t\t\t\t\t\tthis._sessionsCount++;\n\n\t\t\t\t\t\t// The Agent could have been destroyed already.\n\t\t\t\t\t\tif (entry.destroyed) {\n\t\t\t\t\t\t\tconst error = new Error('Agent has been destroyed');\n\n\t\t\t\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\t\t\t\tlistener.reject(error);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsession[kOriginSet] = session.originSet;\n\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst where = this.sessions;\n\n\t\t\t\t\t\t\tif (normalizedOptions in where) {\n\t\t\t\t\t\t\t\tconst sessions = where[normalizedOptions];\n\t\t\t\t\t\t\t\tsessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twhere[normalizedOptions] = [session];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._freeSessionsCount += 1;\n\t\t\t\t\t\treceivedSettings = true;\n\n\t\t\t\t\t\tthis.emit('session', session);\n\n\t\t\t\t\t\tprocessListeners();\n\t\t\t\t\t\tremoveFromQueue();\n\n\t\t\t\t\t\t// TODO: Close last recently used (or least used?) session\n\t\t\t\t\t\tif (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {\n\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check if we haven't managed to execute all listeners.\n\t\t\t\t\t\tif (listeners.length !== 0) {\n\t\t\t\t\t\t\t// Request for a new session with predefined listeners.\n\t\t\t\t\t\t\tthis.getSession(normalizedOrigin, options, listeners);\n\t\t\t\t\t\t\tlisteners.length = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// `session.remoteSettings.maxConcurrentStreams` might get increased\n\t\t\t\t\t\tsession.on('remoteSettings', () => {\n\t\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t\t// In case the Origin Set changes\n\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\t// Shim `session.request()` in order to catch all streams\n\t\t\t\t\tsession[kRequest] = session.request;\n\t\t\t\t\tsession.request = (headers, streamOptions) => {\n\t\t\t\t\t\tif (session[kGracefullyClosing]) {\n\t\t\t\t\t\t\tthrow new Error('The session is gracefully closing. No new streams are allowed.');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst stream = session[kRequest](headers, streamOptions);\n\n\t\t\t\t\t\t// The process won't exit until the session is closed or all requests are gone.\n\t\t\t\t\t\tsession.ref();\n\n\t\t\t\t\t\t++session[kCurrentStreamsCount];\n\n\t\t\t\t\t\tif (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {\n\t\t\t\t\t\t\tthis._freeSessionsCount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstream.once('close', () => {\n\t\t\t\t\t\t\twasFree = isFree();\n\n\t\t\t\t\t\t\t--session[kCurrentStreamsCount];\n\n\t\t\t\t\t\t\tif (!session.destroyed && !session.closed) {\n\t\t\t\t\t\t\t\tcloseSessionIfCovered(this.sessions[normalizedOptions], session);\n\n\t\t\t\t\t\t\t\tif (isFree() && !session.closed) {\n\t\t\t\t\t\t\t\t\tif (!wasFree) {\n\t\t\t\t\t\t\t\t\t\tthis._freeSessionsCount++;\n\n\t\t\t\t\t\t\t\t\t\twasFree = true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst isEmpty = session[kCurrentStreamsCount] === 0;\n\n\t\t\t\t\t\t\t\t\tif (isEmpty) {\n\t\t\t\t\t\t\t\t\t\tsession.unref();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tisEmpty &&\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tthis._freeSessionsCount > this.maxFreeSessions ||\n\t\t\t\t\t\t\t\t\t\t\tsession[kGracefullyClosing]\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t\t\t\t\tprocessListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn stream;\n\t\t\t\t\t};\n\t\t\t\t} catch (error) {\n\t\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\t\tlistener.reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveFromQueue();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tentry.listeners = listeners;\n\t\t\tentry.completed = false;\n\t\t\tentry.destroyed = false;\n\n\t\t\tthis.queue[normalizedOptions][normalizedOrigin] = entry;\n\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t});\n\t}\n\n\trequest(origin, options, headers, streamOptions) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.getSession(origin, options, [{\n\t\t\t\treject,\n\t\t\t\tresolve: session => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolve(session.request(headers, streamOptions));\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}]);\n\t\t});\n\t}\n\n\tcreateConnection(origin, options) {\n\t\treturn Agent.connect(origin, options);\n\t}\n\n\tstatic connect(origin, options) {\n\t\toptions.ALPNProtocols = ['h2'];\n\n\t\tconst port = origin.port || 443;\n\t\tconst host = origin.hostname || origin.host;\n\n\t\tif (typeof options.servername === 'undefined') {\n\t\t\toptions.servername = host;\n\t\t}\n\n\t\treturn tls.connect(port, host, options);\n\t}\n\n\tcloseFreeSessions() {\n\t\tfor (const sessions of Object.values(this.sessions)) {\n\t\t\tfor (const session of sessions) {\n\t\t\t\tif (session[kCurrentStreamsCount] === 0) {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy(reason) {\n\t\tfor (const sessions of Object.values(this.sessions)) {\n\t\t\tfor (const session of sessions) {\n\t\t\t\tsession.destroy(reason);\n\t\t\t}\n\t\t}\n\n\t\tfor (const entriesOfAuthority of Object.values(this.queue)) {\n\t\t\tfor (const entry of Object.values(entriesOfAuthority)) {\n\t\t\t\tentry.destroyed = true;\n\t\t\t}\n\t\t}\n\n\t\t// New requests should NOT attach to destroyed sessions\n\t\tthis.queue = {};\n\t}\n\n\tget freeSessions() {\n\t\treturn getSessions({agent: this, isFree: true});\n\t}\n\n\tget busySessions() {\n\t\treturn getSessions({agent: this, isFree: false});\n\t}\n}\n\nAgent.kCurrentStreamsCount = kCurrentStreamsCount;\nAgent.kGracefullyClosing = kGracefullyClosing;\n\nmodule.exports = {\n\tAgent,\n\tglobalAgent: new Agent()\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}